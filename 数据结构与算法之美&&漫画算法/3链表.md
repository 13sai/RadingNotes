# 链表

> 一种在物理上非连续、非顺序的数据结构，由若干个节点组成。



![数组和链表内存分布区别](http://cxytz.13sai.com/algorithm/d5d5bee4be28326ba3c28373808a62cd.jpg)



## 单（向）链表

![单链表](http://cxytz.13sai.com/algorithm/b93e7ade9bb927baad1348d9a806ddeb.jpg)



其中有第一个结点和最后一个结点是比较特殊的。我们习惯性地把第一个结点叫作**头结点**，把最后一个结点叫作**尾结点**。

其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个**空地址NULL**，表示这是链表上最后一个结点。单向链表如地下党的联络方式，一级一级，单线传递。



在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，时间复杂度是O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就是不连续的。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度是O(1)。



有利就有弊。链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。



![链表删除](http://cxytz.13sai.com/algorithm/452e943788bdeea462d364389bd08a17.jpg)







## **循环链表**



**循环链表是一种特殊的单链表**。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。



![循环链表](http://cxytz.13sai.com/algorithm/86cb7dc331ea958b0a108b911f38d155.jpg)

和单链表相比，**循环链表**的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的[约瑟夫问题](https://zh.wikipedia.org/wiki/约瑟夫斯问题)。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。





## 双向链表

单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。



![双向链表](http://cxytz.13sai.com/algorithm/cbc8ab20276e2f9312030c313a9ef70b.jpg)



从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。



从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

- 删除结点中“值等于某个给定值”的结点；
- 删除给定指针指向的结点。



对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。

尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n)。

对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p->next=q，说明p是q的前驱结点。

但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就搞定了！

同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。





![比较](http://cxytz.13sai.com/algorithm/4f63e92598ec2551069a0eef69db7168.jpg)





## 最近最少使用策略LRU（Least Recently Used）



LRU的原理：当数据在最近一段时间经常被访问，那么它在以后也会经常被访问。这就意味着，如果经常访问的数据，我们需要然其能够快速命中，而不常访问的数据，我们在容量超出限制内，要将其淘汰。



![LRU](http://cxytz.13sai.com/algorithm/LRU.jpg?e=1610449203&token=1gdN7L3hz7Tgyflqo0xuUVm-bOH0G-6mFLSVWeKa:KHJwH0tXXux_0bZhMuNeQ8PMbOc=)



## 如何轻松写出正确的链表代码？



- 理解指针或引用的含义
- 警惕指针丢失和内存泄漏
- 利用哨兵简化实现难度
- 重点留意边界条件处理



### 数组操作对比链表操作

| 结构/操作 | 查找 | 更新 | 插入 | 删除 |
| --------- | ---- | ---- | ---- | ---- |
| 数组      | O(1) | O(1) | O(n) | O(n) |
| 链表      | O(n) | O(1) | O(1) | O(1) |



