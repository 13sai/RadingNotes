# 栈

> 栈：后进先出（LIFO-last in first out）:最后插入的元素最先出来。**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。



实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，我们叫作**链式栈**。

不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是O(1)。





### 应用



编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

我将3+5*8-6这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。



![](http://cxytz.13sai.com/algorithm/bc77c8d33375750f1700eb7778551600.jpg?e=1610955925&token=1gdN7L3hz7Tgyflqo0xuUVm-bOH0G-6mFLSVWeKa:MkrAA9phUrxxfeTSHBI44SNvPTE=)





支持动态扩容的顺序栈

如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下。

![动态扩容](http://cxytz.13sai.com/algorithm/b193adf5db4356d8ab35a1d32142b3da.jpg?e=1610956331&token=1gdN7L3hz7Tgyflqo0xuUVm-bOH0G-6mFLSVWeKa:xFhV4QhVTAN55cexg_VPH69V6kc=)



对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了O(n)。

也就是说，对于入栈操作来说，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)。那平均情况下的时间复杂度又是多少呢？还记得我们在复杂度分析那一节中讲的摊还分析法吗？这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。我们也正好借此来实战一下摊还分析法。